#!/bin/bash

set -eu

basic_setup() {
    if [ "${CHOCPKG_ROOT:-}" = "" ]; then
        echo "CHOCPKG_ROOT not configured - please source setup.sh." \
            >> /dev/stderr
        exit -1
    fi
    INSTALL_DIR="$CHOCPKG_ROOT/install"
    NATIVE_INSTALL_DIR="$CHOCPKG_ROOT/install.native"
    PACKAGES_DIR="$CHOCPKG_ROOT/packages"
    BUILD_DIR="$CHOCPKG_ROOT/build"
    mkdir -p "$INSTALL_DIR" "$NATIVE_INSTALL_DIR" "$PACKAGES_DIR" "$BUILD_DIR"
}

basic_setup

. chocpkg_functions.sh
. "$CHOCPKG_ROOT/buildenv.sh"

# Function that returns true if the package is installed.
check_installed() {
    if [ "${PACKAGE_INSTALLED_TOOL:-}" != "" ]; then
        have_tool "$PACKAGE_INSTALLED_TOOL"
    elif [ "${PKGCONFIG_NAME:-}" != "" ]; then
        if ! have_tool pkg-config; then
            error_exit "pkg-config not installed; please run:" \
                       "    chocpkg install pkg-config"
        fi
        pkg-config --exists "$PKGCONFIG_NAME"
    else
        false
    fi
}

# Given a package name, find the pkgdef file associated with it, source
# the contents of the file and set various variables.
configure_for_package() {
    local package=$1
    local pkg_file="$CHOCPKG_ROOT/pkgdef/$package.sh"
    if [ ! -e "$pkg_file" ]; then
        error_exit "Package file $package.sh not found."
    fi
    # Defaults for package unless overridden:
    PACKAGE_NAME=$package
    PACKAGE_TYPE=target
    PACKAGE_CONFIGURE_OPTS=""
    IS_TAR_BOMB=false
    DEPENDENCIES=""
    GIT_BRANCH=master
    . "$pkg_file"

    # Set the value of PACKAGE_SOURCE_TYPE, based on which variables are set by
    # the package file.
    if [ "${PACKAGE_URL:-}" != "" ]; then
        PACKAGE_FILENAME=$(basename $PACKAGE_URL)
        PACKAGE_SOURCE_TYPE=fetch
    elif [ "${GIT_URL:-}" != "" ]; then
        PACKAGE_SOURCE_TYPE=git
    elif [ "${DEPENDENCIES:-}" != "" ]; then
        PACKAGE_SOURCE_TYPE=package-group
        PACKAGE_TYPE=target  # it doesn't matter
    else
        error_exit "Unknown package type; neither PACKAGE_URL nor GIT_URL set."
    fi

    PACKAGE_BUILD_DIR="$BUILD_DIR/$PACKAGE_NAME"
    if [ "${PACKAGE_VERSION:-}" != "" ]; then
        PACKAGE_BUILD_DIR="$PACKAGE_BUILD_DIR-$PACKAGE_VERSION"
    fi

    # We set up build differently depending on the package type: some packages
    # are for the target we're building for; others are native tools to run on
    # the build machine as part of the build process.
    case "$PACKAGE_TYPE" in
        target)
            PACKAGE_INSTALL_DIR="$INSTALL_DIR"
            ;;
        native)
            PACKAGE_INSTALL_DIR="$NATIVE_INSTALL_DIR"
            ;;
        *)
            error_exit "Unknown package type $PACKAGE_TYPE"
            ;;
    esac

    # We must set PKG_CONFIG_PATH now so we know where to look for packages.
    PKG_CONFIG_PATH="$PACKAGE_INSTALL_DIR/lib/pkgconfig:${PKG_CONFIG_PATH:-}"
    export PKG_CONFIG_PATH

    # When cross-compiling, reconfigure pkg-config to not look for .pc
    # files in the standard system directories; only in our own build
    # directory. It may be that a library is installed on the system
    # but that is useless if it is for the wrong architecture.
    if $IS_CROSS_COMPILE && [ "$PACKAGE_TYPE" = "target" ]; then
        export PKG_CONFIG_LIBDIR=
    fi
}

download_package_file() {
    local dlfile="$PACKAGES_DIR/$PACKAGE_FILENAME"
    if [ ! -e "$dlfile" ]; then
        local tmpfile="$dlfile.part"
        if ! chocurl "$PACKAGE_URL" > $tmpfile; then
            error_exit "Failed to download $PACKAGE_URL"
        fi
        mv "$tmpfile" "$dlfile"
    fi
}

extract_package_file() {
    local dlfile="$PACKAGES_DIR/$PACKAGE_FILENAME"
    # Well-formed tar files contain a single directory that matches their
    # filename, but we support an override for badly-formed tar files too,
    # where we extract everything into a directory with the expected name.
    if $IS_TAR_BOMB; then
        mkdir -p "$PACKAGE_BUILD_DIR"
        cd "$PACKAGE_BUILD_DIR"
    else
        cd "$BUILD_DIR"
    fi
    (gunzip < "$dlfile" | tar -x) || (
        mv "$dlfile" "$dlfile.bad"
        error_exit "Failed to extract $PACKAGE_FILENAME: bad download?"
    )
}

fetch_package() {
    case "$PACKAGE_SOURCE_TYPE" in
        fetch)
            download_package_file
            extract_package_file
            ;;
        git)
            if [ ! -e "$PACKAGE_BUILD_DIR" ]; then
                git clone -b "$GIT_BRANCH" "$GIT_URL" "$PACKAGE_BUILD_DIR"
            fi
            ;;
        package-group)
            error_exit "Can't fetch a package group, only install it."
            ;;
    esac
}

setup_build_environment() {
    CPPFLAGS="-I$PACKAGE_INSTALL_DIR/include"
    LDFLAGS="-L$PACKAGE_INSTALL_DIR/lib ${LDFLAGS:-}"
    export CPPFLAGS LDFLAGS

    # ACLOCAL_PATH is a special case: we include the aclocal paths from both
    # target and native, so that it is possible to get the pkg-config macros.
    ACLOCAL_PATH="$INSTALL_DIR/share/aclocal:${ACLOCAL_PATH:-}"
    ACLOCAL_PATH="$NATIVE_INSTALL_DIR/share/aclocal:$ACLOCAL_PATH"
    export ACLOCAL_PATH
}

# Function invoked before a package is built to set up the build environment,
# if necessary. Can be overridden by pkgdef files.
prebuild_setup() {
    true
}

# This function encapsulates the "./configure; make" process that does the
# actual build of the package. This should work for most autotools-based
# packages but the intention is that this can be overrriden by packages.
do_build() {
    if ! prebuild_setup; then
        error_exit "Failed pre-build setup step for $PACKAGE_NAME."
    fi

    local host_opt=""
    if [ "$PACKAGE_TYPE" = "target" ] && [ "$BUILD_HOST" != "" ]; then
        host_opt="--host=$BUILD_HOST"
    fi

    ./configure --prefix="$PACKAGE_INSTALL_DIR" $host_opt \
                $PACKAGE_CONFIGURE_OPTS || (
        error_exit "Failed to configure package $PACKAGE_NAME for build."
    )

    make $MAKE_OPTS || (
        error_exit "Failed to build package $PACKAGE_NAME."
    )
}

install_dependencies() {
    for dep in $DEPENDENCIES; do
        chocpkg install "$dep"
    done
}

build_package() {
    if [ "$PACKAGE_SOURCE_TYPE" = "package-group" ]; then
        error_exit "Can't build a package group, only install it."
    fi
    install_dependencies
    fetch_package "$PACKAGE_NAME"

    echo =======================================================
    echo "Building $PACKAGE_NAME..."
    echo =======================================================
    echo
    cd "$PACKAGE_BUILD_DIR"

    setup_build_environment
    do_build
}

# Function encapsulating the "make install" step which should work for
# most autotools-based packages, but can be overridden by packages.
do_install() {
    make install || (
         error_exit "Failed to install package $PACKAGE_NAME."
    )
}

reinstall_package() {
    if [ "$PACKAGE_SOURCE_TYPE" = "package-group" ]; then
        install_dependencies
        return
    fi

    build_package "$PACKAGE_NAME"
    cd "$PACKAGE_BUILD_DIR"
    do_install
}

install_package() {
    # Already installed? Don't install again.
    if ! check_installed; then
        reinstall_package
    fi
}

if [ $# -lt 2 ]; then
    echo "Usage: $0 [fetch|build|install|installed] <package name>"
    exit -1
fi

cmd=$1; package=$2
configure_for_package "$package"

case "$cmd" in
    fetch)
        fetch_package
        ;;
    build)
        build_package
        ;;
    reinstall)
        reinstall_package
        ;;
    install)
        install_package
        ;;
    installed)
        check_installed
        ;;
esac

