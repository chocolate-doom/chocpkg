#!/bin/bash

set -eu

# set_chocpkg_root sets the CHOCPKG_ROOT environment variable based on the
# path where the script is located.
set_chocpkg_root() {
    # Assume that the package root is one directory up from the script.
    if [[ "$0" = /* ]]; then
        local script_path="$0"
    else
        local script_path="$PWD/${0#./}"
    fi
    local script_dir=$(dirname "$script_path")
    CHOCPKG_ROOT=$(dirname "$script_dir")

    # Build directory must not contain a space, or bad things happen:
    if [[ "$CHOCPKG_ROOT" = *\ * ]]; then
        cat <<END
        The build scripts are in a path containing a space:

            $CHOCPKG_ROOT

        Builds will probably fail - try moving the build scripts to a
        different directory not containing a space.
END
        exit 1
    fi
}

# basic_setup is invoked on script startup to set various environment variables
# and create basic directories used throughout the rest of the script.
basic_setup() {
    if [ -z "${CHOCPKG_ROOT:-}" ]; then
        set_chocpkg_root
        PATH="$CHOCPKG_ROOT/chocpkg:$CHOCPKG_ROOT/install.native/bin:$PATH"
    fi

    INSTALL_DIR="$CHOCPKG_ROOT/install"
    NATIVE_INSTALL_DIR="$CHOCPKG_ROOT/install.native"
    PACKAGES_DIR="$CHOCPKG_ROOT/packages"
    BUILD_DIR="$CHOCPKG_ROOT/build"

    mkdir -p "$INSTALL_DIR" "$NATIVE_INSTALL_DIR" "$PACKAGES_DIR" "$BUILD_DIR"
}

basic_setup

. chocpkg_functions.sh
. chocpkg_modules.sh
. "$CHOCPKG_ROOT/buildenv.sh"

description() {
    PACKAGE_DESCRIPTION="$*"
}

dependencies() {
    DEPENDENCIES+=" $*"
}

# Given a package name, find the pkgdef file associated with it, source
# the contents of the file and set various variables.
configure_for_package() {
    local package=$1
    local pkg_file="$CHOCPKG_ROOT/pkgdef/$package.sh"
    if [ ! -e "$pkg_file" ]; then
        error_exit "Package file $package.sh not found."
    fi
    # Defaults for package unless overridden:
    PACKAGE_NAME=$package
    PACKAGE_DIR_NAME=$package
    PACKAGE_TYPE=target
    PACKAGE_DESCRIPTION="Package $PACKAGE_NAME"
    DEPENDENCIES=""
    . "$pkg_file"

    PACKAGE_BUILD_DIR="$BUILD_DIR/$PACKAGE_DIR_NAME"

    # We set up build differently depending on the package type: some packages
    # are for the target we're building for; others are native tools to run on
    # the build machine as part of the build process.
    case "$PACKAGE_TYPE" in
        target)
            PACKAGE_INSTALL_DIR="$INSTALL_DIR"
            ;;
        native)
            PACKAGE_INSTALL_DIR="$NATIVE_INSTALL_DIR"
            ;;
        *)
            error_exit "Unknown package type $PACKAGE_TYPE"
            ;;
    esac
}

# setup_build_environment sets environment variables for build. This is
# deliberately only done when needed, as otherwise the value could affect
# child builds when recursing to build dependent packages.
setup_build_environment() {
    CPPFLAGS="-I$PACKAGE_INSTALL_DIR/include"
    LDFLAGS="-L$PACKAGE_INSTALL_DIR/lib ${LDFLAGS:-}"
    export CPPFLAGS LDFLAGS

    # ACLOCAL_PATH is a special case: we include the aclocal paths from both
    # target and native, so that it is possible to get the pkg-config macros.
    ACLOCAL_PATH="$INSTALL_DIR/share/aclocal:${ACLOCAL_PATH:-}"
    ACLOCAL_PATH="$NATIVE_INSTALL_DIR/share/aclocal:$ACLOCAL_PATH"
    export ACLOCAL_PATH

    # We need to find where to look for pkg-config .pc files:
    PKG_CONFIG_PATH="$PACKAGE_INSTALL_DIR/lib/pkgconfig:${PKG_CONFIG_PATH:-}"
    export PKG_CONFIG_PATH

    # When cross-compiling, reconfigure pkg-config to not look for .pc
    # files in the standard system directories; only in our own build
    # directory. It may be that a library is installed on the system
    # but that is useless if it is for the wrong architecture.
    if $IS_CROSS_COMPILE && [ "$PACKAGE_TYPE" = "target" ]; then
        export PKG_CONFIG_LIBDIR=
    fi
}

install_dependencies() {
    for dep in $DEPENDENCIES; do
        chocpkg install "$dep"
    done
}

cmd_installed() {
    setup_build_environment
    check_installed
}

cmd_fetch() {
    do_fetch
}

# Function invoked before a package is built to set up the build environment,
# if necessary. Can be overridden by pkgdef files.
prebuild_setup() {
    true
}

cmd_build() {
    install_dependencies
    chocpkg fetch "$PACKAGE_NAME"

    echo =======================================================
    echo "Building $PACKAGE_NAME..."
    echo =======================================================
    echo
    cd "$PACKAGE_BUILD_DIR"

    setup_build_environment

    if ! prebuild_setup; then
        error_exit "Failed pre-build setup step for $PACKAGE_NAME."
    fi

    do_build
}

cmd_reinstall() {
    chocpkg build "$PACKAGE_NAME"
    cd "$PACKAGE_BUILD_DIR"
    do_install
}

cmd_install() {
    # Already installed? Don't install again.
    if ! chocpkg installed "$PACKAGE_NAME"; then
        chocpkg reinstall "$PACKAGE_NAME"
    fi
}

if [ $# -lt 2 ]; then
    echo "Usage: $0 [fetch|build|install|installed] <package name>"
    exit -1
fi

cmd=$1; package=$2
configure_for_package "$package"

case "$cmd" in
    installed)
        cmd_installed
        ;;
    fetch)
        cmd_fetch
        ;;
    build)
        cmd_build
        ;;
    reinstall)
        cmd_reinstall
        ;;
    install)
        cmd_install
        ;;
esac

